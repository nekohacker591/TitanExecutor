--// 0. CLEANUP
if _G.Titan_Connection then 
    pcall(function() _G.Titan_Connection:Disconnect() end)
    _G.Titan_Connection = nil
end

--// 1. SERVICES
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Camera = Workspace.CurrentCamera

if not RunService:IsRunning() then return end

if CoreGui:FindFirstChild("Titan_V44") then CoreGui.Titan_V44:Destroy() end

--// 2. FORWARD DECLARATIONS
local Screen, Main, Input, Suggest, Inspector, PrevWin
local InsScroll, PScroll, High, Lines, Scroll

--- MODIFIED: Added state tracking for the current path context ---
local State = {
    Results={}, Query="", Index=1, Active=false, IgnoreUpdate=false, 
    ParentObj=nil, ARClone=nil, ARConn=nil, LastInspected=nil, 
    Scale=1, Mode="Static", PartMap={}, ArgMode=false, ArgQuote="",
    Navigating=false, SymbolTable = {}, AR_Load_Thread = nil,
    CurrentParentPath = nil, CurrentSeparator = "."
}

--// 3. CONFIG (UNCHANGED)
local Config = {
    Colors = { Main = Color3.fromRGB(30, 30, 30), Editor = Color3.fromRGB(20, 20, 20), Bar = Color3.fromRGB(45, 45, 45), Text = Color3.fromRGB(240, 240, 240), Accent = Color3.fromRGB(0, 120, 215), Suggest = Color3.fromRGB(40, 40, 40), Inspector = Color3.fromRGB(25, 25, 25), Syntax = { Kw = "#FF79C6", Num = "#BD93F9", Str = "#F1FA8C", Com = "#6272A4", Blt = "#8BE9FD", Mtd = "#50FA7B", Var = "#FFFFFF" } }, Font = Enum.Font.Code, ItemHeight = 20
}

--// 4. SYNTAX ENGINE (UNCHANGED)
local Syntax = {}
function Syntax.Highlight(text)
    text = text:gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
    local rep = {}; local id = 0
    local function mask(t, c) id=id+1; local k="\0"..id.."\0"; rep[k]=string.format('<font color="%s">%s</font>',c,t); return k end
    text = text:gsub("(%-%-.+)", function(m) return mask(m, Config.Colors.Syntax.Com) end)
    text = text:gsub('(".-")', function(m) return mask(m, Config.Colors.Syntax.Str) end); text = text:gsub("('.-')", function(m) return mask(m, Config.Colors.Syntax.Str) end)
    local kws = {["local"]=1,["function"]=1,["if"]=1,["then"]=1,["else"]=1,["end"]=1,["return"]=1,["while"]=1,["do"]=1,["for"]=1,["in"]=1,["true"]=1,["false"]=1,["nil"]=1}
    local blts = {["game"]=1,["workspace"]=1,["script"]=1,["task"]=1,["math"]=1,["table"]=1,["string"]=1,["coroutine"]=1,["print"]=1,["warn"]=1,["error"]=1,["wait"]=1,["Enum"]=1,["Instance"]=1,["CFrame"]=1,["Vector3"]=1,["Vector2"]=1,["Color3"]=1,["UDim2"]=1,["UDim"]=1,["Ray"]=1,["TweenInfo"]=1,["tick"]=1,["pcall"]=1,["typeof"]=1,["require"]=1}
    text = text:gsub("(%a[%w_]*)", function(w) if kws[w] then return mask(w, Config.Colors.Syntax.Kw) end; if blts[w] then return mask(w, Config.Colors.Syntax.Blt) end; return w end)
    text = text:gsub("local%s+([%a_][%w_]*)", function(full, var) return full:gsub(var, mask(var, Config.Colors.Syntax.Var)) end)
    return text:gsub("%z%d+%z", function(k) return rep[k] or k end)
end

--// 5. INTELLISENSE ENGINE (UNCHANGED)
local Intel = {}
Intel.Libs = {task=true, math=true, table=true, string=true, coroutine=true, debug=true, os=true, utf8=true, bit32=true}
Intel.GlobalFuncs = {["assert"]=true, ["collectgarbage"]=true, ["error"]=true, ["getfenv"]=true, ["getmetatable"]=true, ["ipairs"]=true, ["loadstring"]=true, ["next"]=true, ["pairs"]=true, ["pcall"]=true, ["print"]=true, ["rawequal"]=true, ["rawget"]=true, ["rawset"]=true, ["require"]=true, ["select"]=true, ["setfenv"]=true, ["setmetatable"]=true, ["tonumber"]=true, ["tostring"]=true, ["type"]=true, ["unpack"]=true, ["xpcall"]=true, ["_G"]=true, ["_VERSION"]=true, ["spawn"]=true, ["delay"]=true, ["wait"]=true, ["tick"]=true, ["time"]=true, ["typeof"]=true, ["settings"]=true, ["UserSettings"]=true, ["elapsedTime"]=true, ["stats"]=true, ["plugin"]=true, ["warn"]=true}
Intel.Constructors = {"Vector3", "Vector2", "CFrame", "Color3", "UDim2", "UDim", "Ray", "Rect", "Region3", "Region3int16", "NumberRange", "NumberSequence", "ColorSequence", "ColorSequenceKeypoint", "PhysicalProperties", "RaycastParams", "OverlapParams", "TweenInfo", "Axes", "Faces", "Enum", "_G", "shared", "BrickColor", "Vector3int16", "PathWaypoint"}
Intel.HighPriority = {["Part"] = 100, ["Model"] = 100, ["Folder"] = 100, ["Script"] = 95, ["LocalScript"] = 95, ["ModuleScript"] = 95, ["MeshPart"] = 90, ["ScreenGui"] = 90, ["Frame"] = 85, ["TextLabel"] = 85, ["TextButton"]= 85, ["RemoteEvent"] = 80, ["BindableEvent"] = 80, ["Animation"] = 80, ["Humanoid"] = 80, ["Tool"] = 80, ["Sound"] = 75, ["Highlight"] = 75}
Intel.Services = {}; Intel.CreatableInstances = {}; Intel.Classes = {} 
Intel.Classes["task"] = { Inherits = "<<<ROOT>>>", Properties = {}, Methods = {"wait", "spawn", "defer", "delay", "cancel"}, Events = {}, Callbacks = {}, MemberInfo={ wait = { Type="Function", ReturnType="number" } } }
Intel.Classes["math"] = { Inherits = "<<<ROOT>>>", Properties = {"pi", "huge"}, Methods = {"abs", "acos", "asin", "atan", "ceil", "cos", "deg", "exp", "floor", "fmod", "rad", "log", "log10", "max", "min", "pow", "sin", "sqrt", "tan", "clamp", "sign", "round"}, Events = {}, Callbacks = {}, MemberInfo={} }
Intel.Classes["string"] = { Inherits = "<<<ROOT>>>", Properties = {}, Methods = {"byte", "char", "find", "format", "gmatch", "gsub", "len", "lower", "match", "rep", "reverse", "sub", "upper", "split"}, Events = {}, Callbacks = {}, MemberInfo={} }
Intel.Classes["table"] = { Inherits = "<<<ROOT>>>", Properties = {}, Methods = {"insert", "remove", "sort", "concat", "create", "find", "getn", "maxn", "pack", "unpack", "move", "clear"}, Events = {}, Callbacks = {}, MemberInfo={} }
Intel.Classes["coroutine"] = { Inherits = "<<<ROOT>>>", Properties = {}, Methods = {"create", "resume", "yield", "wrap", "close", "isyieldable"}, Events = {}, Callbacks = {}, MemberInfo={} }
Intel.ArgumentHandlers = { ["new"] = function(funcPath, argText) local parentClass = funcPath:match("^(.-)%.new$"); local res = {}; if parentClass == "Instance" then local query = argText:match('^["\']?([%w_]*)["\']?$') or ""; for _, cls in ipairs(Intel.CreatableInstances) do if cls:lower():find(query:lower(), 1, true) then local weight = Intel.HighPriority[cls] or 1; table.insert(res, {N=cls, T="Class", W=weight, X="Creatable"}) end end; table.sort(res, function(a,b) return a.W > b.W end) elseif parentClass == "CFrame" then table.insert(res, {N="CFrame.new(x, y, z, ...)", T="Signature"}) elseif parentClass == "Vector3" then table.insert(res, {N="Vector3.new(x, y, z)", T="Signature"}) elseif parentClass == "Vector2" then table.insert(res, {N="Vector2.new(x, y)", T="Signature"}) elseif parentClass == "UDim2" then table.insert(res, {N="UDim2.new(xScale, xOff, yScale, yOff)", T="Signature"}) end; return res end, ["GetService"] = function(funcPath, argText) local query = argText:match('^["\']?([%w_]*)["\']?$') or ""; local res = {}; for _, svc in ipairs(Intel.Services) do if svc:lower():find(query:lower(), 1, true) then table.insert(res, {N=svc, T="Service", W=10, X="Service"}) end end; return res end, ["FindFirstChild"] = function(funcPath, argText) local parentPath = funcPath:match("^(.-):FindFirstChild$"); local parentObj = parentPath and Intel.ResolveLive(parentPath); if not parentObj then return {} end; local query = argText:match('^["\']?([%w_]*)["\']?$') or ""; local res = {}; if typeof(parentObj) == "Instance" then for _,c in ipairs(parentObj:GetChildren()) do if c.Name:lower():find(query:lower(), 1, true) then table.insert(res, {N=c.Name, T="Child", W=60, X=c.ClassName}) end end end; return res end, ["require"] = function(funcPath, argText) local res = {}; local seenPaths = {}; local function search(inst) if inst:IsA("ModuleScript") then local path = inst:GetFullName(); if not seenPaths[path] then table.insert(res, { N = path, T = "Module", W = 100, X = inst.Name }); seenPaths[path] = true end end; for _, child in ipairs(inst:GetChildren()) do search(child) end end; search(game); return res end }
Intel.ArgumentHandlers["WaitForChild"] = Intel.ArgumentHandlers["FindFirstChild"]; Intel.ArgumentHandlers["fromRGB"] = function() return {{N="Color3.fromRGB(r, g, b)", T="Signature"}} end; Intel.ArgumentHandlers["fromHSV"] = function() return {{N="Color3.fromHSV(h, s, v)", T="Signature"}} end
local function LoadAPIDump() local url = "https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/roblox/Full-API-Dump.json"; local success, content = pcall(function() return game:HttpGet(url, true) end); if not success then warn("Full API Dump fetch failed.") return end; local dump = HttpService:JSONDecode(content); for _, classDef in ipairs(dump.Classes) do local className = classDef.Name; local structure = {Inherits = classDef.Superclass, Properties = {}, Methods = {}, Events = {}, Callbacks = {}, MemberInfo = {}}; for _, member in ipairs(classDef.Members) do local isDeprecated = false; if member.Tags then for _, tag in ipairs(member.Tags) do if tag == "Deprecated" then isDeprecated = true break end end end; if not isDeprecated then if member.MemberType == "Property" then table.insert(structure.Properties, member.Name); structure.MemberInfo[member.Name] = { Type="Property", ValueType = (member.ValueType.Category == "Enum" and "Enum" or member.ValueType.Name) } elseif member.MemberType == "Function" then table.insert(structure.Methods, member.Name); structure.MemberInfo[member.Name] = { Type="Function", ReturnType = (member.ReturnType.Category == "Enum" and "Enum" or member.ReturnType.Name) } elseif member.MemberType == "Event" then table.insert(structure.Events, member.Name); structure.MemberInfo[member.Name] = { Type="Event" } elseif member.MemberType == "Callback" then table.insert(structure.Callbacks, member.Name); structure.MemberInfo[member.Name] = { Type="Callback" } end end end; Intel.Classes[className] = structure; local isService = false; local isCreatable = true; if classDef.Tags then for _, tag in ipairs(classDef.Tags) do if tag == "Service" then isService = true end if tag == "NotCreatable" or tag == "Abstract" then isCreatable = false end end end; if isService then table.insert(Intel.Services, className) end; if isCreatable then table.insert(Intel.CreatableInstances, className) end end end
task.spawn(LoadAPIDump)
function Intel.GetAllProperties(className) local allProps = {}; local seen = {}; local currentClass = className; while currentClass and currentClass ~= "<<<ROOT>>>" do local clsDef = Intel.Classes[currentClass]; if clsDef and clsDef.Properties then for _, propName in ipairs(clsDef.Properties) do if not seen[propName] then table.insert(allProps, propName); seen[propName] = true end end end; currentClass = clsDef and clsDef.Inherits end; table.sort(allProps); return allProps end
function Intel.GetPathContext(text) local len = #text; local i = len; local depth = 0; local inQuote = nil; while i > 0 do local c = text:sub(i, i); if inQuote then if c == inQuote and text:sub(i-1, i-1) ~= "\\" then inQuote = nil end elseif c == '"' or c == "'" then inQuote = c elseif c == "]" or c == ")" or c == "}" then depth = depth + 1 elseif c == "[" or c == "(" or c == "{" then depth = depth - 1 elseif depth == 0 and c:match("[^%w_%.%:%[\"']") then return text:sub(i+1) end; i = i - 1 end; return text end
function Intel.TokenizePath(path) local tokens = {}; local i = 1; local len = #path; while i <= len do local c = path:sub(i,i); if c == "." or c == ":" then i = i + 1 elseif c == "[" then local endBracket = path:find("]", i, true); if not endBracket then break end; local content = path:sub(i+1, endBracket-1); local inner = content:match("^[\"'](.+)[\"']$"); table.insert(tokens, inner or content); i = endBracket + 1 else local nextSep = path:find("[%.%:%[]", i); local segment = nextSep and path:sub(i, nextSep-1) or path:sub(i); table.insert(tokens, segment); i = nextSep or (len + 1) end end; return tokens end
function Intel.ResolvePathVirtually(path, symbolTable) if not path or path == "" then return nil end; local className, remainingPath; local varName = path:match("^([%a_][%w_]*)"); if varName and symbolTable and symbolTable[varName] then className = symbolTable[varName].ClassName; remainingPath = path:sub(#varName + 1) elseif path:find('^game:GetService%s*%(', 1, true) then local service = path:match('^game:GetService%s*%("%s*([%w_]+)%s*"%)'); local endPos = path:find("%)", 1, true); if service and endPos then className = service; remainingPath = path:sub(endPos + 1) else return nil end elseif path:find('^Instance.new%s*%(', 1, true) then local class = path:match('^Instance.new%s*%("%s*([%w_]+)%s*"%)'); local endPos = path:find("%)", 1, true); if class and endPos then className = class; remainingPath = path:sub(endPos + 1) else return nil end elseif varName then if varName == "game" then className = "DataModel" elseif varName == "workspace" then className = "Workspace" elseif Intel.Libs[varName] then className = varName elseif Intel.Classes[varName] then className = varName else return nil end; remainingPath = path:sub(#varName + 1) else return nil end; while remainingPath and remainingPath ~= "" do local separator, memberName = remainingPath:match("^(.)([%a_][%w_]*)"); if not memberName then break end; local memberInfo = nil; local tempClass = className; while tempClass and tempClass ~= "<<<ROOT>>>" and not memberInfo do if Intel.Classes[tempClass] and Intel.Classes[tempClass].MemberInfo[memberName] then memberInfo = Intel.Classes[tempClass].MemberInfo[memberName] end; tempClass = Intel.Classes[tempClass] and Intel.Classes[tempClass].Inherits end; if memberInfo then className = memberInfo.ValueType or memberInfo.ReturnType or "any"; remainingPath = remainingPath:sub(#separator + #memberName + 1) else local liveParent = Intel.ResolveLive(path:sub(1, #path - #remainingPath)); if typeof(liveParent) == "Instance" then local child = liveParent:FindFirstChild(memberName); if child then className = child.ClassName; remainingPath = remainingPath:sub(#separator + #memberName + 1); continue end end; return { ClassName = "any" } end end; return { ClassName = className } end
function Intel.ParseLocals(fullText) local locals = {}; for name in fullText:gmatch("function%s+([%a_][%w_.:]*)") do name = name:match("([^.:]+)$") or name; locals[name] = { Type = "Function", ClassName = "Function" } end; for name, expr in fullText:gmatch("local%s+([%a_][%w_]*)%s*=%s*(.+)") do expr = expr:match("^%s*(.-)%s*$"); local resolved = Intel.ResolvePathVirtually(expr, locals); locals[name] = { Type = "Variable", ClassName = resolved and resolved.ClassName or "any" } end; return locals end
function Intel.ResolveLive(path) if not path or path == "" then return nil end; local tokens = Intel.TokenizePath(path); if #tokens == 0 then return nil end; local start = tokens[1]; local root = nil; if start == "game" then root = game elseif start == "workspace" then root = workspace elseif start == "script" then root = script elseif start == "Enum" then root = Enum elseif Intel.Libs[start] then return start elseif start == "Instance" then return Instance else pcall(function() root = _G[start] or game:GetService(start) end) end; if not root then return nil end; local o = root; for k = 2, #tokens do local key = tokens[k]; if key ~= "" then local success, new_o = pcall(function() return o[key] end); if not success and typeof(o) == "Instance" then o = o:FindFirstChild(key) else o = new_o end; if not o then return nil end end end; return o end
function Intel.Scan(txt, fullText) State.ArgMode = false; State.ArgQuote = ""; local locals = Intel.ParseLocals(fullText); State.SymbolTable = locals; local funcPath, argText = txt:match("([%w_.:]+)%s*%(([^)]*)$"); if funcPath then local memberName = funcPath:match("[:.](%w+)$") or funcPath; if Intel.ArgumentHandlers[memberName] then local res = Intel.ArgumentHandlers[memberName](funcPath, argText); if #res > 0 then State.ArgMode = true; return res, (argText:match('["\']?([%w_%.]*)["\']?$') or "") end end end; local context = Intel.GetPathContext(txt) or ""; local parentPath, separator, query = context:match("^(.-)([:%.])([%w_]*)$"); if not parentPath then query = context; parentPath = ""; separator = "" end; local res = {}; local seen = {}; local function add(n, t, extra, w) if not seen[n] and n:lower():find(query:lower(), 1, true) then local finalWeight = w; if (n == "Name" or n == "Parent" or n == "CFrame" or n == "Position") then finalWeight = finalWeight + 5 end; table.insert(res, {N=n, T=t, X=extra or "", W=finalWeight}); seen[n]=true end end; if parentPath == "" then for name, info in pairs(locals) do add(name, info.Type, info.ClassName, 50) end; local roots = {"game","workspace","script", "Enum", "Instance"}; for _,v in ipairs(roots) do add(v, "Global", "", 45) end; for k,_ in pairs(Intel.Libs) do add(k, "Library", "", 40) end; for k,_ in pairs(Intel.GlobalFuncs) do add(k, "Function", "", 35) end; for _,v in ipairs(Intel.Constructors) do add(v, "Constructor", "", 30) end else local parentObjVirtual = Intel.ResolvePathVirtually(parentPath, locals); if parentObjVirtual and parentObjVirtual.ClassName ~= "any" then local currentClass = parentObjVirtual.ClassName; while currentClass and currentClass ~= "<<<ROOT>>>" do local clsDef = Intel.Classes[currentClass]; if clsDef then if separator == "." then for _,p in ipairs(clsDef.Properties) do add(p, "Property", currentClass, 20) end; for _,e in ipairs(clsDef.Events) do add(e, "Event", currentClass, 15) end; for _,c in ipairs(clsDef.Callbacks) do add(c, "Callback", currentClass, 15) end; for _,m in ipairs(clsDef.Methods) do add(m, "Method", currentClass, 5) end elseif separator == ":" then for _,m in ipairs(clsDef.Methods) do add(m, "Method", currentClass, 20) end end; currentClass = clsDef.Inherits else break end end; local parentObjLive = Intel.ResolveLive(parentPath); if separator == "." and typeof(parentObjLive) == "Instance" then pcall(function() for _,c in ipairs(parentObjLive:GetChildren()) do add(c.Name, "Child", c.ClassName, 60) end end) end end end; table.sort(res, function(a,b) if a.W == b.W then return a.N < b.N else return a.W > b.W end end); return res, query end

--// 6. UI & EVENT HANDLING
Screen = Instance.new("ScreenGui"); Screen.Name = "Titan_V44"; Screen.ResetOnSpawn = false; Screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; pcall(function() Screen.Parent = CoreGui end); if not Screen.Parent then Screen.Parent = Players.LocalPlayer:WaitForChild("PlayerGui") end
Main = Instance.new("Frame", Screen); Main.Name = "Main"; Main.Size = UDim2.fromOffset(600, 400); Main.Position = UDim2.fromScale(0.5,0.5); Main.AnchorPoint = Vector2.new(0.5,0.5); Main.BackgroundColor3 = Config.Colors.Main; Main.Active = true; Main.Draggable = true; Instance.new("UICorner", Main).CornerRadius = UDim.new(0,6)
local Top = Instance.new("Frame", Main); Top.Size=UDim2.new(1,0,0,30); Top.BackgroundColor3=Config.Colors.Bar; Top.BorderSizePixel=0; local Title = Instance.new("TextLabel", Top); Title.Text=" TITAN IDE"; Title.Size=UDim2.new(1,-80,1,0); Title.BackgroundTransparency=1; Title.TextColor3=Config.Colors.Text; Title.TextXAlignment=0; Title.Font=Enum.Font.GothamBold; Title.TextSize=12; local Close = Instance.new("TextButton", Top); Close.Text="X"; Close.Size=UDim2.new(0,30,1,0); Close.Position=UDim2.new(1,-30,0,0); Close.BackgroundTransparency=1; Close.TextColor3=Color3.new(1,0.3,0.3); Close.Font=Enum.Font.GothamBold; Close.MouseButton1Click:Connect(function() Screen:Destroy() end)
local EditArea = Instance.new("Frame", Main); EditArea.Size=UDim2.new(1,0,1,-65); EditArea.Position=UDim2.new(0,0,0,30); EditArea.BackgroundColor3=Config.Colors.Editor; Lines = Instance.new("TextLabel", EditArea); Lines.Size=UDim2.new(0,35,1,0); Lines.BackgroundColor3=Config.Colors.Bar; Lines.TextColor3=Color3.new(0.5,0.5,0.5); Lines.TextYAlignment=0; Lines.Font=Config.Font; Lines.TextSize=14; Lines.Text="1"; Scroll = Instance.new("ScrollingFrame", EditArea); Scroll.Size=UDim2.new(1,-35,1,0); Scroll.Position=UDim2.new(0,35,0,0); Scroll.BackgroundTransparency=1; Scroll.BorderSizePixel=0; Scroll.CanvasSize=UDim2.new(0,0,0,0); Scroll.AutomaticCanvasSize=Enum.AutomaticSize.XY; High = Instance.new("TextLabel", Scroll); High.Size=UDim2.new(1,0,1,0); High.BackgroundTransparency=1; High.TextXAlignment=0; High.TextYAlignment=0; High.Font=Config.Font; High.TextSize=14; High.RichText=true; High.Text=""; High.ZIndex=2; Input = Instance.new("TextBox", Scroll); Input.Size=UDim2.new(1,0,1,0); Input.BackgroundTransparency=1; Input.TextXAlignment=0; Input.TextYAlignment=0; Input.Font=Config.Font; Input.TextSize=14; Input.MultiLine=true; Input.ClearTextOnFocus=false; Input.TextTransparency=0.5; Input.TextColor3=Config.Colors.Text; Input.Text=""; Input.ZIndex=3; Input.AutomaticSize=Enum.AutomaticSize.XY
Suggest = Instance.new("ScrollingFrame", Screen); Suggest.Name = "SuggestBox"; Suggest.Size = UDim2.fromOffset(250, 200); Suggest.BackgroundColor3 = Config.Colors.Suggest; Suggest.BorderColor3 = Config.Colors.Accent; Suggest.BorderSizePixel = 1; Suggest.Visible = false; Suggest.ZIndex = 20; Suggest.CanvasSize = UDim2.new(0,0,0,0); Suggest.AutomaticCanvasSize = Enum.AutomaticSize.Y; Suggest.ScrollBarThickness = 4; Instance.new("UIListLayout", Suggest)
local Exec = Instance.new("TextButton", Main); Exec.Text="EXECUTE"; Exec.Size=UDim2.new(0,100,0,25); Exec.Position=UDim2.new(1,-110,1,-30); Exec.BackgroundColor3=Config.Colors.Accent; Exec.TextColor3=Color3.new(1,1,1); Exec.Font=Enum.Font.GothamBold; Exec.TextSize=12; Instance.new("UICorner", Exec).CornerRadius=UDim.new(0,4); Exec.MouseButton1Click:Connect(function() local f,e=loadstring(Input.Text); if f then task.spawn(f) else warn(e) end end)
Inspector = Instance.new("Frame", Screen); Inspector.Name = "Inspector"; Inspector.Size = UDim2.fromOffset(220, 300); Inspector.Position = UDim2.new(0.7, 0, 0.5, -150); Inspector.BackgroundColor3 = Config.Colors.Inspector; Inspector.BorderColor3 = Config.Colors.Bar; Inspector.BorderSizePixel = 1; Inspector.Visible = false; Inspector.Active = true; Inspector.Draggable = true; local InsTop = Instance.new("Frame", Inspector); InsTop.Size=UDim2.new(1,0,0,25); InsTop.BackgroundColor3=Config.Colors.Bar; local InsTitle = Instance.new("TextLabel", InsTop); InsTitle.Text=" INSPECTOR"; InsTitle.Size=UDim2.new(1,-25,1,0); InsTitle.BackgroundTransparency=1; InsTitle.TextColor3=Config.Colors.Text; InsTitle.Font=Enum.Font.GothamBold; InsTitle.TextSize=12; local InsClose = Instance.new("TextButton", InsTop); InsClose.Text="X"; InsClose.Size=UDim2.new(0,25,1,0); InsClose.Position=UDim2.new(1,-25,0,0); InsClose.BackgroundTransparency=1; InsClose.TextColor3=Color3.new(1,0.3,0.3); InsClose.MouseButton1Click:Connect(function() Inspector.Visible=false; CleanupAR() end); InsScroll = Instance.new("ScrollingFrame", Inspector); InsScroll.Size = UDim2.new(1,0,1,-25); InsScroll.Position = UDim2.new(0,0,0,25); InsScroll.BackgroundTransparency = 1; InsScroll.BorderSizePixel = 0; InsScroll.ScrollBarThickness = 4; InsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y; Instance.new("UIListLayout", InsScroll)
PrevWin = Instance.new("Frame", Screen); PrevWin.Name = "Preview"; PrevWin.Size = UDim2.fromOffset(200, 240); PrevWin.Position = UDim2.new(0.9, 0, 0.5, -150); PrevWin.BackgroundColor3 = Color3.new(0,0,0); PrevWin.BackgroundTransparency = 0.5; PrevWin.BorderColor3 = Config.Colors.Accent; PrevWin.BorderSizePixel = 1; PrevWin.Visible = false; PrevWin.Active = true; PrevWin.Draggable = true; local PrevTitle = Instance.new("TextLabel", PrevWin); PrevTitle.Text=" PREVIEW (DRAG)"; PrevTitle.Size=UDim2.new(1,-25,0,20); PrevTitle.BackgroundColor3=Config.Colors.Accent; PrevTitle.TextColor3=Color3.new(1,1,1); PrevTitle.Font=Enum.Font.GothamBold; PrevTitle.TextSize=10; local PrevClose = Instance.new("TextButton", PrevWin); PrevClose.Text="X"; PrevClose.Size=UDim2.new(0,25,0,20); PrevClose.Position=UDim2.new(1,-25,0,0); PrevClose.BackgroundColor3=Config.Colors.Accent; PrevClose.TextColor3=Color3.new(1,1,1); PrevClose.MouseButton1Click:Connect(function() PrevWin.Visible=false; CleanupAR() end); local ControlFrame = Instance.new("Frame", PrevWin); ControlFrame.Size = UDim2.new(1,0,0,30); ControlFrame.Position = UDim2.new(0,0,1,-30); ControlFrame.BackgroundColor3 = Config.Colors.Bar; ControlFrame.BorderSizePixel = 0; local ScaleLabel = Instance.new("TextLabel", ControlFrame); ScaleLabel.Text="Scale:"; ScaleLabel.Size=UDim2.new(0,40,1,0); ScaleLabel.BackgroundTransparency=1; ScaleLabel.TextColor3=Config.Colors.Text; ScaleLabel.Font=Config.Font; ScaleLabel.TextSize=12; local ScaleSlider = Instance.new("TextButton", ControlFrame); ScaleSlider.Text=""; ScaleSlider.Size=UDim2.new(0,80,0,4); ScaleSlider.Position=UDim2.new(0,45,0.5,-2); ScaleSlider.BackgroundColor3=Color3.new(0.3,0.3,0.3); local ScaleFill = Instance.new("Frame", ScaleSlider); ScaleFill.Size=UDim2.new(0.5,0,1,0); ScaleFill.BackgroundColor3=Config.Colors.Accent; ScaleFill.BorderSizePixel=0; local ModeBtn = Instance.new("TextButton", ControlFrame); ModeBtn.Text="Static"; ModeBtn.Size=UDim2.new(0,60,0,20); ModeBtn.Position=UDim2.new(1,-65,0.5,-10); ModeBtn.BackgroundColor3=Config.Colors.Editor; ModeBtn.TextColor3=Config.Colors.Text; ModeBtn.Font=Config.Font; ModeBtn.TextSize=12; Instance.new("UICorner", ModeBtn).CornerRadius=UDim.new(0,4); ModeBtn.MouseButton1Click:Connect(function() if State.Mode == "Static" then State.Mode = "Live"; ModeBtn.Text = "Live"; ModeBtn.TextColor3 = Color3.new(0,1,0) else State.Mode = "Static"; ModeBtn.Text = "Static"; ModeBtn.TextColor3 = Config.Colors.Text end end); local DraggingSlider = false; ScaleSlider.MouseButton1Down:Connect(function() DraggingSlider = true end); UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then DraggingSlider = false end end); UserInputService.InputChanged:Connect(function(input) if DraggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then local relX = math.clamp((input.Position.X - ScaleSlider.AbsolutePosition.X) / ScaleSlider.AbsoluteSize.X, 0, 1); ScaleFill.Size = UDim2.new(relX, 0, 1, 0); State.Scale = 0.5 + (relX * 1.5) end end)
local function ScrollToSelection() local itemH = Config.ItemHeight; local currentY = (State.Index - 1) * itemH; if currentY >= Suggest.CanvasPosition.Y + Suggest.AbsoluteSize.Y then Suggest.CanvasPosition = Vector2.new(0, currentY - Suggest.AbsoluteSize.Y + itemH) elseif currentY < Suggest.CanvasPosition.Y then Suggest.CanvasPosition = Vector2.new(0, currentY) end end
local function CleanupAR() if State.AR_Load_Thread then coroutine.close(State.AR_Load_Thread); State.AR_Load_Thread = nil end; if State.ARClone then State.ARClone:Destroy(); State.ARClone = nil end; if State.ARConn then State.ARConn:Disconnect(); State.ARConn = nil end; State.PartMap = {} end
local function MapHierarchy(real, clone) if real:IsA("BasePart") and clone:IsA("BasePart") then State.PartMap[real] = clone; clone.Anchored = true; clone.CanCollide = false; clone.CanTouch = false; clone.CanQuery = false end; local rChildren = real:GetChildren(); local cChildren = clone:GetChildren(); for i = 1, #rChildren do if cChildren[i] then MapHierarchy(rChildren[i], cChildren[i]) end end end
local function UpdateAR(obj) if not obj then return end; CleanupAR(); local wasArch = obj.Archivable; obj.Archivable = true; local success, clone = pcall(function() return obj:Clone() end); obj.Archivable = wasArch; if not success or not clone then return end; if clone:IsA("GuiObject") or clone:IsA("ScreenGui") then local holder = Instance.new("Part", Workspace); holder.Transparency=1; holder.Anchored=true; holder.CanCollide=false; holder.Size=Vector3.new(1,1,1); local bb = Instance.new("BillboardGui", holder); bb.Size=UDim2.fromScale(5, 5); bb.AlwaysOnTop=true; if clone:IsA("ScreenGui") then for _,c in ipairs(clone:GetChildren()) do c.Parent=bb end; clone:Destroy() else clone.Parent=bb; clone.Position=UDim2.fromScale(0.5,0.5); clone.AnchorPoint=Vector2.new(0.5,0.5) end; State.ARClone = holder; State.ARConn = RunService.RenderStepped:Connect(function() if not (PrevWin and PrevWin.Visible) then return end; local center = PrevWin.AbsolutePosition + Vector2.new(PrevWin.AbsoluteSize.X/2, -100); local ray = Camera:ScreenPointToRay(center.X, center.Y); holder.CFrame = CFrame.new(ray.Origin + ray.Direction * (10 / State.Scale)) end) elseif clone:IsA("Folder") or clone:IsA("Configuration") or (not clone:IsA("BasePart") and not clone:IsA("Model") and not clone:IsA("Accessory") and not clone:IsA("Tool")) then local tempModel = Instance.new("Model"); tempModel.Name = "AR_Preview_Container"; State.ARClone = tempModel; State.AR_Load_Thread = coroutine.create(function() local children = obj:GetChildren(); for i, child in ipairs(children) do if not child:IsA("Script") and not child:IsA("LocalScript") and not child:IsA("ModuleScript") then local childWasArch = child.Archivable; child.Archivable = true; local s, cClone = pcall(function() return child:Clone() end); child.Archivable = childWasArch; if s and cClone then cClone.Parent = tempModel end end; if i % 30 == 0 then task.wait() end end; tempModel.Parent = Workspace; if tempModel:IsA("Model") then local cf, size = tempModel:GetBoundingBox(); local maxDim = math.max(size.X, size.Y, size.Z); if maxDim > 0 then tempModel:ScaleTo(5 / maxDim) end end; local angle = 0; State.ARConn = RunService.RenderStepped:Connect(function(dt) if not (PrevWin and PrevWin.Visible and State.ARClone) then return end; local center = PrevWin.AbsolutePosition + Vector2.new(PrevWin.AbsoluteSize.X/2, 100); local ray = Camera:ScreenPointToRay(center.X, center.Y); local depth = 10 / State.Scale; local targetPos = ray.Origin + ray.Direction * depth; angle = angle + dt * 0.5; local rot = CFrame.fromEulerAnglesYXZ(0, angle, 0); if State.ARClone:IsA("Model") then State.ARClone:PivotTo(CFrame.new(targetPos) * rot) end end) end); coroutine.resume(State.AR_Load_Thread) elseif clone:IsA("BasePart") or clone:IsA("Model") or clone:IsA("Tool") or clone:IsA("Accessory") then clone.Parent = Workspace; State.ARClone = clone; State.PartMap = {}; MapHierarchy(obj, clone); for _, d in ipairs(clone:GetDescendants()) do if d:IsA("LuaSourceContainer") then d:Destroy() end end; if clone:IsA("Model") then local cf, size = clone:GetBoundingBox(); local maxDim = math.max(size.X, size.Y, size.Z); if maxDim > 0 then clone:ScaleTo(5 / maxDim) end end; local angle = 0; State.ARConn = RunService.RenderStepped:Connect(function(dt) if not (PrevWin and PrevWin.Visible and State.ARClone) then return end; local center = PrevWin.AbsolutePosition + Vector2.new(PrevWin.AbsoluteSize.X/2, 100); local ray = Camera:ScreenPointToRay(center.X, center.Y); local depth = 10 / State.Scale; local targetPos = ray.Origin + ray.Direction * depth; if State.Mode == "Live" then local realPivot = (obj:IsA("Model") and obj:GetPivot()) or (obj:IsA("BasePart") and obj.CFrame) or CFrame.new(); local offset = CFrame.new(targetPos) * realPivot:Inverse(); for rp, cp in pairs(State.PartMap) do if rp and rp.Parent then cp.CFrame = offset * rp.CFrame; cp.Transparency = rp.Transparency; cp.Color = rp.Color end end else angle = angle + dt * 0.5; local rot = CFrame.fromEulerAnglesYXZ(0, angle, 0); if State.ARClone:IsA("Model") then State.ARClone:PivotTo(CFrame.new(targetPos) * rot) elseif State.ARClone:IsA("BasePart") then State.ARClone.CFrame = CFrame.new(targetPos) * rot end end end) else clone:Destroy() end end

--- MODIFIED: UpdateInspector now has smarter logic to find the selected object ---
local function UpdateInspector(overrideObj) 
    local obj = overrideObj
    if not obj and not State.ArgMode then
        local item = State.Results[State.Index]
        -- This new logic constructs the full path of the selected suggestion and resolves it.
        if item and State.CurrentParentPath and State.CurrentParentPath ~= "" then
            -- Handle bracket notation for names with spaces/special chars
            local memberName = item.N
            local fullPath
            if memberName:match("^[%a_][%w_]*$") then
                fullPath = State.CurrentParentPath .. State.CurrentSeparator .. memberName
            else
                fullPath = State.CurrentParentPath .. '["' .. memberName .. '"]'
            end
            obj = Intel.ResolveLive(fullPath)
        elseif item and not State.CurrentParentPath then -- For global variables
            obj = Intel.ResolveLive(item.N)
        end
    end

    if obj and typeof(obj) == "Instance" then 
        if State.LastInspected == obj and not overrideObj then return end
        State.LastInspected = obj; Inspector.Visible = true; PrevWin.Visible = true
        local title = Inspector:FindFirstChild("Frame") and Inspector.Frame:FindFirstChild("TextLabel"); if title then title.Text = " " .. obj.Name .. " ["..obj.ClassName.."]" end
        for _,v in pairs(InsScroll:GetChildren()) do if v:IsA("Frame") then v:Destroy() end end
        local props = Intel.GetAllProperties(obj.ClassName); for _, prop in ipairs(props) do 
            local success, val = pcall(function() return obj[prop] end)
            if success and val ~= nil then 
                local row = Instance.new("Frame", InsScroll); row.Size=UDim2.new(1,0,0,20); row.BackgroundTransparency=1
                local n = Instance.new("TextLabel", row); n.Size=UDim2.new(0.4,0,1,0); n.BackgroundTransparency=1; n.Text=" "..prop; n.TextColor3=Config.Colors.Accent; n.TextXAlignment=0; n.Font=Config.Font; n.TextSize=12
                local v = Instance.new("TextLabel", row); v.Size=UDim2.new(0.6,-5,1,0); v.Position=UDim2.new(0.4,0,0,0); v.BackgroundTransparency=1; v.Text=tostring(val):gsub("\n", " "); v.TextColor3=Config.Colors.Text; v.TextXAlignment=2; v.Font=Config.Font; v.TextSize=12; v.TextTruncate=Enum.TextTruncate.AtEnd 
            end 
        end
        UpdateAR(obj) 
    else 
        if not overrideObj then -- Don't hide inspector if we're just hovering over something non-instantiable
            State.LastInspected = nil; Inspector.Visible = false; PrevWin.Visible = false; CleanupAR() 
        end
    end 
end

local function UpdateVisuals() if not Suggest then return end; for i, btn in ipairs(Suggest:GetChildren()) do if btn:IsA("TextButton") then btn.BackgroundColor3 = (btn.LayoutOrder == State.Index) and Config.Colors.Accent or Config.Colors.Suggest end end; ScrollToSelection(); UpdateInspector() end
local function Accept() if not State.Active or not State.Results[State.Index] then return end; State.IgnoreUpdate = true; local item = State.Results[State.Index]; local full = Input.Text; local cur = Input.CursorPosition; local ins = item.N; if item.T == "Signature" then return end; local startPos = cur; if State.ArgMode then local quote = State.ArgQuote or (ins:match(" ") and '"' or ''); ins = quote .. ins .. quote; while startPos > 0 do local char = full:sub(startPos-1, startPos-1); if char == '(' or char == ',' then break end; startPos = startPos -1 end else while startPos > 0 do local char = full:sub(startPos-1, startPos-1); if not char:match("[%w_]") then break end; startPos = startPos - 1 end; local needsBrackets = not ins:match("^[_%a][_%w]*$"); if needsBrackets then local preChar = full:sub(startPos-1, startPos-1); if preChar == "." then startPos = startPos - 1 end; ins = '["' .. ins .. '"]' end; if item.T == "Method" or item.T == "Function" then ins = ins.."()" end end; local before = full:sub(1, startPos-1); local after = full:sub(cur); Input.Text = before .. ins .. after; local newPos = #before + #ins + 1; if (item.T == "Method" or item.T == "Function") and not State.ArgMode then newPos = newPos - 1 end; Input.CursorPosition = newPos; Suggest.Visible = false; State.Active = false; State.IgnoreUpdate = false; task.defer(function() if Input and Input.Parent then Input:CaptureFocus() end end) end
UserInputService.InputBegan:Connect(function(input) if not (Input and Input.Parent and Input:IsFocused()) then return end; if input.KeyCode == Enum.KeyCode.Quote then local c = Input.CursorPosition; if Input.Text:sub(c, c) == '"' then Input.TextEditable = false; task.defer(function() Input.CursorPosition = c; Input.TextEditable = true; Input:CaptureFocus() end) else Input.TextEditable = false; task.defer(function() Input.Text = Input.Text:sub(1, c - 1) .. '""' .. Input.Text:sub(c); Input.CursorPosition = c; Input.TextEditable = true; Input:CaptureFocus() end) end end; if State.Active then local key = input.KeyCode; local update = false; if key == Enum.KeyCode.Up then State.Index = math.max(1, State.Index - 1); update=true elseif key == Enum.KeyCode.Down then State.Index = math.min(#State.Results, State.Index + 1); update=true elseif key == Enum.KeyCode.Tab or key == Enum.KeyCode.Return then Input.TextEditable = false; Accept(); RunService.RenderStepped:Wait(); Input.TextEditable = true; Input:CaptureFocus() end; if update then Input.TextEditable = false; State.Navigating = true; UpdateVisuals(); RunService.RenderStepped:Wait(); Input.TextEditable = true; Input:CaptureFocus(); State.Navigating = false end end end)
local function PositionSuggestWindow(pre) local linesBefore = select(2, pre:gsub("\n", "\n")); local lastLine = pre:match("[^\n]*$") or ""; local vec = TextService:GetTextSize(lastLine, 14, Config.Font, Vector2.new(9999,9999)); local abs = Main.AbsolutePosition; local x = abs.X + 35 + vec.X - Scroll.CanvasPosition.X + 10; local y = abs.Y + 30 + (linesBefore+1)*15 - Scroll.CanvasPosition.Y + 5; Suggest.Position = UDim2.fromOffset(x,y) end

--- MODIFIED: Update function now saves the path context to the State table ---
local function Update() 
    if not (Input and Suggest) then return end; if State.IgnoreUpdate or State.Navigating then return end
    local text = Input.Text; if text:find("\t") then local c = Input.CursorPosition; Input.Text = text:gsub("\t", "  "); Input.CursorPosition = c + 1; return end
    High.Text = Syntax.Highlight(text); local _,lc = text:gsub("\n","\n"); local l=""; for i=1,lc+1 do l=l..i.."\n" end; Lines.Text=l
    local cur = Input.CursorPosition; if cur < 1 then Suggest.Visible=false; State.Active=false; UpdateInspector(nil); return end
    local pre = text:sub(1, cur-1)
    
    local context = Intel.GetPathContext(pre)
    local parentPath, separator, query = context:match("^(.-)([:%.])([%w_]*)$")
    if not parentPath and not separator then 
        parentPath = nil
        State.CurrentParentPath = nil -- Typing at global scope
    elseif separator and (query == nil or query == "") then
        parentPath = context:sub(1, #context - 1)
        State.CurrentParentPath = parentPath
        State.CurrentSeparator = separator
    else
        State.CurrentParentPath = parentPath
        State.CurrentSeparator = separator or "."
    end
    
    State.ParentObj = parentPath and Intel.ResolveLive(parentPath) or nil
    local res, q = Intel.Scan(pre, text)
    local sameList = (#res == #State.Results); if sameList then for i=1, #res do if res[i].N ~= State.Results[i].N then sameList=false; break end end end
    if sameList then PositionSuggestWindow(pre); if not Suggest.Visible and #res > 0 then Suggest.Visible=true end; UpdateInspector(); return end
    if #res == 0 then Suggest.Visible=false; State.Active=false; UpdateInspector(); return end
    local oldName = State.Results[State.Index] and State.Results[State.Index].N; local newIndex = 1; if oldName then for i, item in ipairs(res) do if item.N == oldName then newIndex = i; break end end end
    State.Results = res; State.Query = q; State.Index = newIndex; State.Active = true
    for _,v in pairs(Suggest:GetChildren()) do if v:IsA("TextButton") then v:Destroy() end end
    for i=1, #res do local d = res[i]; local b = Instance.new("TextButton", Suggest); b.Size=UDim2.new(1,0,0,Config.ItemHeight); b.BackgroundColor3=(i==State.Index) and Config.Colors.Accent or Config.Colors.Suggest; b.TextColor3=Config.Colors.Text; b.TextXAlignment=0; b.Font=Config.Font; b.TextSize=13; b.ZIndex=21; b.LayoutOrder=i; local txt = "  " .. d.N; if d.X ~= "" and d.X ~= "Creatable" then txt = txt .. " ["..d.X.."]" end; b.Text = txt; local f = Instance.new("Frame", b); f.Size=UDim2.new(0,3,1,0); f.BorderSizePixel=0; f.ZIndex=22; if d.T=="Child" or d.T=="Instance" then f.BackgroundColor3=Color3.fromRGB(139, 233, 253) elseif d.T=="Property" then f.BackgroundColor3=Color3.fromRGB(80, 250, 123) elseif d.T=="Method" or d.T=="Function" or d.T=="Class" or d.T=="Library" then f.BackgroundColor3=Color3.fromRGB(189, 147, 249) elseif d.T=="Event" then f.BackgroundColor3=Color3.fromRGB(255, 121, 198) elseif d.T=="Service" then f.BackgroundColor3=Color3.fromRGB(255, 184, 108) elseif d.T=="EnumItem" then f.BackgroundColor3=Color3.fromRGB(241, 250, 140) elseif d.T=="Signature" then f.BackgroundColor3=Color3.fromRGB(150,150,150) else f.BackgroundColor3=Color3.fromRGB(98, 114, 164) end; b.MouseButton1Click:Connect(function() State.Index = i; Input:CaptureFocus(); Input.CursorPosition = cur; Accept() end) end
    PositionSuggestWindow(pre); Suggest.Size = UDim2.fromOffset(250, math.min(#res, 8) * Config.ItemHeight); Suggest.Visible = true; ScrollToSelection(); UpdateInspector() 
end

task.spawn(function() while task.wait(0.3) do if State.Active and not State.Navigating then pcall(Update) end end end)
Input:GetPropertyChangedSignal("Text"):Connect(Update)
Input:GetPropertyChangedSignal("CursorPosition"):Connect(Update)
task.spawn(Update)